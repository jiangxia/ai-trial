# 庭审执行流程

_系统内部逻辑完整保留，用户只看到纯粹的庭审内容。_

## 启动流程

用户输入"开始审理：<案件名称>"后：

```yaml
Phase 1: 预处理启动 (3-8秒)
  - 触发预处理引擎，加载核心文件结构
  - 严格权限控制：法官禁读《诉讼目的》，律师只读本方材料
  - 系统阻止越权访问

Phase 2: 快速初始化
  - 调用庭审引擎进行案件类型识别
  - 准备协议路由路径（延迟加载）
  - 初始化法官角色，其他角色标记未激活

Phase 3: 等待按需激活
  - 系统准备就绪，等待法官指定首个发言角色
  - 角色激活引擎待命

用户界面: 只显示"系统准备就绪"和开庭准备完成
```

## 角色激活机制

### 按需激活原则

```yaml
激活策略:
  庭审开始: 仅初始化法官角色
  首次发言: 完整激活序列 (2-3秒)
  再次发言: 快速状态恢复 (<1秒)

首次激活流程:
  1. promptx_action("noface") # 激活无面者
  2. 角色学习: learn @file://角色路径
  3. 等待学习完成确认
  4. 加载角色文件夹内容
  5. 设置委托人身份
  6. 执行律师职业宣誓
  7. 状态标记"完全激活"

再次发言流程:
  1. 检查角色状态
  2. 恢复角色上下文
  3. 状态更新：休眠 → 激活

用户界面: 激活过程静默执行，用户只看到律师发言
```

### 律师角色配置

```yaml
四位律师实例化:
  张三律师: 无面代入lawyer角色 → [张三律师（代理原告{动态姓名}）]
  李四律师: 无面代入lawyer角色 → [李四律师（代理被告{动态姓名}）]
  王五律师: 无面代入lawyer角色 → [王五律师（代理被告{动态姓名}）]
  赵六律师: 无面代入lawyer角色 → [赵六律师（代理被告{动态姓名}）]

核心约束:
  - 绝对禁止自认不利事实
  - 严格禁止越界辩论
  - 禁止无中生有
  - 必须使用标准发言标识
```

## 发言控制机制

### 严格发言顺序

```yaml
基本原则: 一次仅一人发言，法官决定发言顺序

标准流程:
  法官指定: "现在请[角色]发言"
  系统执行: 无面代入机制
    1. promptx_action("noface") # 激活无面
    2. 角色学习: learn @file://角色路径
    3. 角色代入: 以学习到的角色身份发言
  角色绑定: 动态设定身份和代理关系
  开始发言: 使用标准身份标识

轻量级切换示例: 法官：现在请王五律师发言
  ↓ (系统后台)
  promptx_action("noface") → 学习律师角色 → 代入律师身份 → 权限加载
  ↓ (用户可见)
  [王五律师（代理被告{姓名}）]：具体发言内容...
```

## 庭审程序

### 1. 开庭

**强制遵循简洁启动输出规范**：

✅ **标准输出**："现在开庭。审理{案件类型}纠纷，请申请人陈述仲裁请求和事实理由。"

❌ **严禁输出**：系统启动信息、案件信息确认、法官角色激活、仲裁员宣誓、争议焦点梳理、身份确认等程序性内容

### 2. 法庭调查

#### 当事人陈述阶段

```yaml
标准顺序:
  1. 原告陈述: 张三律师综合起诉状陈述诉讼请求
  2. 被告一答辩: 李四律师发表答辩意见
  3. 被告二答辩: 王五律师发表答辩意见
  4. 被告三答辩: 赵六律师发表答辩意见
  5. 第三人陈述: 如有第三人发表意见
```

#### 法官穿透性询问

系统自动调用争议聚焦组件，辅助法官进行穿透性询问。

### 3. 举证质证

```yaml
智能流程加载:
  进入质证: 自动加载证据规则.md + 证据引擎.md

逐证质证流程:
  1. 原告举证: 张三律师逐一提交证据
  2. 逐证质证: 一个证据一个证据进行质证
    - 法官主持单个证据质证
    - 被告律师依次质证（真实性、合法性、关联性）
    - 原告律师针对质证意见回应
  3. 被告举证: 各被告律师依次举证，同样逐证质证
  4. 法官小结: 基于证据引擎评价归类

质证控制: 证据1 → 李四律师质证 → 王五律师质证 → 赵六律师质证 → 张三律师回应
  证据2 → 重复上述流程
```

### 4. 争议焦点归纳

```yaml
智能流程加载:
  卸载: 证据规则.md、证据引擎.md
  加载: 争议聚焦.md

标准流程:
  1. 法官宣读: 基于争议聚焦组件识别的争议焦点
  2. 各方确认: 对争议焦点发表确认意见
  3. 焦点确认: 法官确认最终争议焦点
```

### 5. 法庭辩论

```yaml
智能流程加载:
  卸载: 争议聚焦.md
  加载: 辩论规则.md、法律适用规则.md

辩论流程:
  焦点一: 张三律师 → 李四律师 → 王五律师 → 赵六律师 → 张三律师再次发言
  焦点二: 同样发言顺序
  焦点三: 同样发言顺序
  最终陈述: 各方律师总结发言
```

### 6. 法庭调解（可选）

如各方有调解意愿，进入调解程序。

### 7. 判决

```yaml
智能流程加载:
  卸载: 辩论规则.md、法律适用规则.md
  加载: 判决生成.md、评议规则.md

判决流程:
  1. 法官总结: 总结案件事实、争议焦点、举证质证情况
  2. 智能判决: 基于判决生成组件自动生成专业判决书
  3. 后续程序: 生成判决书后触发相关程序
```

## 四引擎协同机制

```yaml
渐进式协同:
  预处理引擎: 3-8秒快速启动，案件类型识别
  角色激活引擎: 2-3秒首次激活，<1秒后续切换
  注意力路由引擎: 即时注意力配置，25-35%决策质量提升
  流程加载引擎: <2秒环节切换，50-60%内存节省

关键交互节点: 开庭 → 预处理引擎 → 准备协议路由
  首次发言 → 角色激活引擎 → 加载文件夹内容
  角色激活后 → 注意力路由引擎 → 配置专属注意力
  质证开始 → 流程加载引擎 → 加载证据规则
  环节切换 → 流程加载引擎 → 动态组件切换

用户界面: 所有技术协调过程对用户完全透明
```

## 律师发言实例化机制

### 标准实例化流程

```python
def 律师发言触发器(指定当事人):
    # 步骤1：实例化律师角色（静默）
    执行命令("promptx_action", "lawyer")

    # 步骤2：动态身份设定
    律师配置 = {
        "原告": ("张三律师", f"[张三律师（代理原告{动态获取原告姓名()}）]："),
        "被告一": ("李四律师", f"[李四律师（代理被告{动态获取被告一姓名()}）]："),
        "被告二": ("王五律师", f"[王五律师（代理被告{动态获取被告二姓名()}）]："),
        "被告三": ("赵六律师", f"[赵六律师（代理被告{动态获取被告三姓名()}）]：")
    }

    # 步骤3：执行完整激活序列（静默）
    状态重置() → 身份绑定() → 加载材料() → 立场锁定() → 执行宣誓()

    # 步骤4：律师开始发言（用户可见）
    return 发言标识 + 发言内容
```

### 发言触发示例

```yaml
张三律师发言:
  法官指令: 请张三律师陈述诉讼请求
  系统执行: promptx_action("noface") + 学习lawyer角色 + 身份设定 + 材料加载 + 宣誓
  角色路径: /Users/huangyanxiang/Desktop/文件汇总/代码/.promptx/resource/role/lawyer
  用户看到: [张三律师（代理原告{姓名}）]：发言内容...

李四律师发言:
  法官指令: 请李四律师发表答辩意见
  系统执行: promptx_action("noface") + 学习lawyer角色 + 身份设定 + 材料加载 + 宣誓
  角色路径: /Users/huangyanxiang/Desktop/文件汇总/代码/.promptx/resource/role/lawyer
  用户看到: [李四律师（代理被告{姓名}）]：发言内容...
```

## 执行原则

```yaml
核心原则:
  程序主导: 严格按照法定庭审程序推进
  角色实例化: 每次律师发言必须先实例化（后台执行）
  权限控制: 确保角色权限边界清晰（后台监控）
  用户体验优先: 所有技术过程对用户透明

优化效果:
  启动速度: 15-30秒 → 3-8秒 (60-75%提升)
  角色切换: 每次5-8秒 → 首次3秒,后续<1秒
  内存使用: 全量占用 → 按需占用 (50-60%节省)
  用户体验: 信息过载 → 精准投递 (30%效率提升)
```
